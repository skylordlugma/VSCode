import threading
import queue
import time
import math
import socket
import struct
from collections import deque, Counter
from dataclasses import dataclass
from datetime import datetime
import os

import cv2
import cv2.aruco as aruco
import numpy as np

import customtkinter as ctk
from PIL import Image


# ============================================================
# CONFIG (defaults)
# ============================================================

# Camera
CAM_INDEX = 1
FRAME_W = 1280
FRAME_H = 720

# ArUco
ARUCO_DICT = aruco.getPredefinedDictionary(aruco.DICT_4X4_250)
ARUCO_PARAMS = aruco.DetectorParameters()

# IDs (theme naming)
CRITIBOT_ID = 1              # critical marker to unlock everything (Criti-Bot)
TARGET_ID = 1                # target marker (Criti-Bot body)
ROBOBALL_ID = 145            # chaser marker (Robo-Ball)

# Preprocess robustness
USE_CLAHE = True
USE_BILATERAL = True
clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8)) if USE_CLAHE else None

# Tracking smoothing / stability
MAX_HISTORY = 30
ALPHA_POS = 0.35
MIN_STEP_PX = 2

# Defaults for UI-tunables (these become live parameters)
DEFAULT_ID_VOTE_WINDOW = 7
ID_MIN_VOTES = 4
GATE_DIST_PX = 25
LOST_TIMEOUT_S = 0.35

# Robot1 prediction drawing
PATH_LEN_PX = 800
DEFAULT_MIN_SPEED_PX_S = 5.0

# Camera control defaults (UI can override)
DEFAULT_AUTO_EXPOSURE = True
DEFAULT_EXPOSURE = -6
DEFAULT_GAIN = 0

# ============================================================
# UDP TARGETS
# ============================================================

UDP_IP = "138.38.229.153"

# Criti-Bot "engage" pulse output (1 byte 0x01)
UDP_PORT_CRITICAL = 671
TRIGGER_BYTE = b"\x01"
PULSE_DURATION_S = 0.25
REARM_TIMEOUT_S = 5.0
CRITICAL_SEND_RATE_HZ = 30.0

# Robo-Ball steering output (float32 radians)
UDP_PORT_ANGLE = 672
SEND_RATE_HZ_ANGLE = 50.0
FLIP_ANGLE_SIGN = False
HEADING_OFFSET_RAD = 0.0

# Angle "lock-on" latch
DEFAULT_ANGLE_ZERO_THRESH_RAD = 0.30  # Changed from ANGLE_ZERO_THRESH_RAD = 0.3
ANGLE_ZERO_FRAMES = 1

# Impact pulse output (uint8=1 pulse)
UDP_PORT_IMPACT = 673
DEFAULT_CRASH_RADIUS_PX = 120
HYST_PX = 8
MIN_PULSE_PERIOD_S = 0.25

# Big impact indicator
CRASH_FLASH_S = 1.2
CRASH_FLASH_HZ = 6.0

# ============================================================
# CHASER SPEED (px/s) = SPHERE_SPEED_M_S * PX_PER_M
# ============================================================
SPHERE_SPEED_M_S = 1.66
DEFAULT_PX_PER_M = 20.0
MAX_INTERCEPT_T = 20.0

# IP stability (arm-then-stream)
IP_STABLE_PX = 6.0
IP_STABLE_FRAMES = 10
IP_LOST_RESET_S = 0.30

# UI refresh
UI_POLL_MS = 15
ANGLE_SENT_SHOW_S = 2.0

# Snapshots
SNAP_DIR = "snapshots"


# ============================================================
# SHARED CONFIG (LIVE TUNING)
# ============================================================

class SharedConfig:
    """
    Thread-safe live-tunable parameters controlled from UI.
    Vision thread reads these every loop.
    """
    def __init__(self):
        self._lock = threading.Lock()

        # Vision/logic tunables
        self.crash_radius_px = int(DEFAULT_CRASH_RADIUS_PX)
        self.px_per_m = float(DEFAULT_PX_PER_M)
        self.min_speed_px_s = float(DEFAULT_MIN_SPEED_PX_S)
        self.id_vote_window = int(DEFAULT_ID_VOTE_WINDOW)
        self.angle_zero_thresh_rad = float(DEFAULT_ANGLE_ZERO_THRESH_RAD)  # Added

        # Camera tunables
        self.auto_exposure = bool(DEFAULT_AUTO_EXPOSURE)
        self.exposure = float(DEFAULT_EXPOSURE)
        self.gain = float(DEFAULT_GAIN)

        # Internal: bump when UI wants immediate re-apply of camera settings
        self._cam_apply_req = 0

    def get(self):
        with self._lock:
            return {
                "crash_radius_px": int(self.crash_radius_px),
                "px_per_m": float(self.px_per_m),
                "min_speed_px_s": float(self.min_speed_px_s),
                "id_vote_window": int(self.id_vote_window),
                "angle_zero_thresh_rad": float(self.angle_zero_thresh_rad),  # Added
                "auto_exposure": bool(self.auto_exposure),
                "exposure": float(self.exposure),
                "gain": float(self.gain),
                "cam_apply_req": int(self._cam_apply_req),
            }

    def set_crash_radius(self, v: int):
        with self._lock:
            self.crash_radius_px = int(max(10, min(600, v)))

    def set_px_per_m(self, v: float):
        with self._lock:
            self.px_per_m = float(max(1.0, min(500.0, v)))

    def set_min_speed(self, v: float):
        with self._lock:
            self.min_speed_px_s = float(max(0.0, min(500.0, v)))

    def set_id_vote_window(self, v: int):
        with self._lock:
            self.id_vote_window = int(max(1, min(25, v)))

    def set_angle_thresh(self, v: float):  # Added
        with self._lock:
            self.angle_zero_thresh_rad = float(max(0.0, min(math.pi, v)))

    def set_camera(self, auto_exposure: bool | None = None, exposure: float | None = None, gain: float | None = None):
        with self._lock:
            if auto_exposure is not None:
                self.auto_exposure = bool(auto_exposure)
            if exposure is not None:
                self.exposure = float(exposure)
            if gain is not None:
                self.gain = float(gain)

    def request_apply_camera(self):
        with self._lock:
            self._cam_apply_req += 1


# ============================================================
# HELPERS
# ============================================================

def preprocess_gray(frame_bgr: np.ndarray) -> np.ndarray:
    gray = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2GRAY)
    if USE_CLAHE and clahe is not None:
        gray = clahe.apply(gray)
    if USE_BILATERAL:
        gray = cv2.bilateralFilter(gray, 5, 50, 50)
    return gray

def centroid_from_corners(corners_4x2: np.ndarray) -> np.ndarray:
    return np.mean(corners_4x2, axis=0)

def dist2(a, b):
    dx = float(a[0] - b[0])
    dy = float(a[1] - b[1])
    return dx * dx + dy * dy

def majority_vote(id_deque):
    if not id_deque:
        return None, 0
    c = Counter(id_deque)
    winner, votes = c.most_common(1)[0]
    return int(winner), int(votes)

def estimate_velocity(history_deque):
    if len(history_deque) < 6:
        return None
    t = np.array([h[0] for h in history_deque], dtype=np.float64)
    p = np.array([h[1] for h in history_deque], dtype=np.float64)
    t0 = t[0]
    tt = t - t0
    A = np.vstack([tt, np.ones_like(tt)]).T
    vx, _ = np.linalg.lstsq(A, p[:, 0], rcond=None)[0]
    vy, _ = np.linalg.lstsq(A, p[:, 1], rcond=None)[0]
    return np.array([float(vx), float(vy)], dtype=np.float64)

def wrap_to_pi(a: float) -> float:
    return (a + math.pi) % (2.0 * math.pi) - math.pi

def angle_from_vec(vx: float, vy: float) -> float:
    return math.atan2(vy, vx)

def draw_x(img, pt, size=12, color=(255, 0, 255), thickness=3):
    x, y = pt
    cv2.line(img, (x - size, y - size), (x + size, y + size), color, thickness, cv2.LINE_AA)
    cv2.line(img, (x - size, y + size), (x + size, y - size), color, thickness, cv2.LINE_AA)

def draw_banner(out_img, text, top_left=(20, 20), pad=10,
                bg_color=(0, 0, 0), text_color=(255, 255, 255), scale=0.9):
    x, y = top_left
    (tw, th), baseline = cv2.getTextSize(text, cv2.FONT_HERSHEY_SIMPLEX, scale, 2)
    w = tw + 2 * pad
    h = th + baseline + 2 * pad
    cv2.rectangle(out_img, (x, y), (x + w, y + h), bg_color, -1)
    cv2.putText(out_img, text, (x + pad, y + pad + th),
                cv2.FONT_HERSHEY_SIMPLEX, scale, text_color, 2, cv2.LINE_AA)

def compute_intercept_point(p1, v1, p2, chaser_speed, t_max=5.0):
    r = (p1 - p2).astype(np.float64)
    v = v1.astype(np.float64)
    s = float(chaser_speed)

    a = float(np.dot(v, v) - s * s)
    b = float(2.0 * np.dot(r, v))
    c = float(np.dot(r, r))

    if abs(a) < 1e-9:
        if abs(b) < 1e-9:
            return None, None
        t = -c / b
        if t > 0.0:
            t = min(t, t_max)
            return (p1 + v1 * t).astype(np.float64), float(t)
        return None, None

    disc = b * b - 4.0 * a * c
    if disc < 0.0:
        return None, None

    sqrt_disc = math.sqrt(disc)
    t1 = (-b - sqrt_disc) / (2.0 * a)
    t2 = (-b + sqrt_disc) / (2.0 * a)

    candidates = [t for t in (t1, t2) if t > 0.0]
    if not candidates:
        return None, None

    t = min(candidates)
    if t > t_max:
        return None, None

    ip = (p1 + v1 * t).astype(np.float64)
    return ip, float(t)


@dataclass
class UiStatus:
    error: str | None
    engaged: bool
    unlocked: bool
    pulse_active: bool
    lock_on: bool
    angle_zero_latched: bool
    last_angle: float | None
    impact_flash: bool
    fps: float
    rejected_n: int

    # Show live tunables in UI
    crash_radius_px: int
    px_per_m: float
    min_speed_px_s: float
    id_vote_window: int
    exposure: float
    gain: float
    auto_exposure: bool


# ============================================================
# WORKER: VISION + UDP RUNNER
# ============================================================

class VisionRunner:
    def __init__(self, q: queue.Queue, cfg: SharedConfig):
        self.q = q
        self.cfg = cfg
        self.stop_evt = threading.Event()

        # UI control states
        self.engaged = False
        self.paused = False

        # UDP sockets
        self.sock_critical = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.sock_angle = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.sock_impact = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

        self.critical_send_interval = 1.0 / max(1.0, CRITICAL_SEND_RATE_HZ)
        self.angle_send_min_dt = 1.0 / max(1.0, SEND_RATE_HZ_ANGLE)

        # Camera init
        self.cap = cv2.VideoCapture(CAM_INDEX, cv2.CAP_DSHOW)
        if not self.cap.isOpened():
            raise RuntimeError(f"Camera not opened. CAM_INDEX={CAM_INDEX} (try 0 then 1)")
        self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, FRAME_W)
        self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, FRAME_H)

        self._last_cam_apply_req = -1
        self._last_cam_apply_t = 0.0

        # Apply initial camera settings from cfg
        self._apply_camera_settings(force=True)

        self.last_rgb_frame = None  # snapshot source
        self.full_reset()

    # --- UI controls ---
    def set_engaged(self, v: bool):
        self.engaged = bool(v)

    def toggle_pause(self):
        self.paused = not self.paused

    def request_stop(self):
        self.stop_evt.set()

    def clear_tracking_only(self):
        self.hist_target.clear()
        self.hist_ball.clear()
        self.trail_target.clear()
        self.pos_target_filt = None
        self.pos_ball_filt = None
        self.last_trail_pt = None

        # NOTE: id_vote_window is live -> we recreate deques on window change elsewhere
        self.id_votes_target.clear()
        self.id_votes_ball.clear()

        self.last_seen_target_t = None
        self.last_seen_ball_t = None

        self.ip_last = None
        self.ip_stable_count = 0
        self.ip_last_seen_t = None
        self.lock_on = False

        self.last_sent_angle = None
        self.last_sent_time = None
        self.last_udp_sent_time = None

        self.angle_zero_count = 0
        self.angle_zero_latched = False

        self.last_impact_pulse_t = 0.0
        self.impact_latched = False
        self.last_impact_event_t = None

    def full_reset(self):
        # Engagement gate
        self.engaged = False
        self.paused = False

        # Criti-bot engage pulse gating
        self.armed = True
        self.pulse_active = False
        self.pulse_start_time = None
        self.last_seen_critical_t = None
        self.last_critical_send_t = 0.0
        self.unlocked = False

        # Tracking
        self.hist_target = deque(maxlen=MAX_HISTORY)
        self.hist_ball = deque(maxlen=MAX_HISTORY)

        self.trail_target = deque(maxlen=400)
        self.pos_target_filt = None
        self.pos_ball_filt = None
        self.last_trail_pt = None

        # Votes deques are live-sized from cfg
        w = self.cfg.get()["id_vote_window"]
        self.id_votes_target = deque(maxlen=w)
        self.id_votes_ball = deque(maxlen=w)

        self.last_seen_target_t = None
        self.last_seen_ball_t = None

        # Intercept / lock-on
        self.ip_last = None
        self.ip_stable_count = 0
        self.ip_last_seen_t = None
        self.lock_on = False

        # Angle streaming
        self.last_sent_angle = None
        self.last_sent_time = None
        self.last_udp_sent_time = None

        self.angle_zero_count = 0
        self.angle_zero_latched = False

        # Impact
        self.last_impact_pulse_t = 0.0
        self.impact_latched = False
        self.last_impact_event_t = None

    def send_impact_pulse(self, now_s: float):
        payload = struct.pack("B", 1)
        self.sock_impact.sendto(payload, (UDP_IP, UDP_PORT_IMPACT))
        self.last_impact_pulse_t = now_s
        self.last_impact_event_t = now_s

    def snapshot(self):
        if self.last_rgb_frame is None:
            return None
        os.makedirs(SNAP_DIR, exist_ok=True)
        ts = datetime.now().strftime("%Y%m%d_%H%M%S")
        path = os.path.join(SNAP_DIR, f"roboball_vs_critibot_{ts}.png")
        bgr = cv2.cvtColor(self.last_rgb_frame, cv2.COLOR_RGB2BGR)
        cv2.imwrite(path, bgr)
        return path

    def shutdown(self):
        try:
            self.cap.release()
        except Exception:
            pass
        for s in (self.sock_critical, self.sock_angle, self.sock_impact):
            try:
                s.close()
            except Exception:
                pass

    # --- camera control ---
    def _apply_camera_settings(self, force: bool = False):
        """
        Apply exposure/gain/auto-exposure to camera.
        Throttled to avoid fighting the driver.
        """
        cfg = self.cfg.get()
        req = cfg["cam_apply_req"]
        now = time.time()

        # Apply if forced, or requested by UI, or every ~0.5s to keep in sync
        if (not force) and (req == self._last_cam_apply_req) and ((now - self._last_cam_apply_t) < 0.5):
            return

        auto_exp = cfg["auto_exposure"]
        exposure = cfg["exposure"]
        gain = cfg["gain"]

        try:
            # On Windows DirectShow, auto exposure often uses:
            # 0.25 = manual, 0.75 = auto (common convention). Not universal.
            if auto_exp:
                self.cap.set(cv2.CAP_PROP_AUTO_EXPOSURE, 0.75)
            else:
                self.cap.set(cv2.CAP_PROP_AUTO_EXPOSURE, 0.25)
                self.cap.set(cv2.CAP_PROP_EXPOSURE, float(exposure))
                self.cap.set(cv2.CAP_PROP_GAIN, float(gain))
        except Exception:
            pass

        self._last_cam_apply_req = req
        self._last_cam_apply_t = now

    # --- UI queue output ---
    def _push_status(self, status: UiStatus):
        try:
            self.q.put_nowait(("status", status))
        except queue.Full:
            pass

    def _push_frame(self, rgb: np.ndarray):
        self.last_rgb_frame = rgb
        try:
            self.q.put_nowait(("frame", rgb))
        except queue.Full:
            pass

    # --- main loop ---
    def run(self):
        while not self.stop_evt.is_set():
            loop_start = time.perf_counter()

            # Apply camera settings if needed
            self._apply_camera_settings(force=False)

            ret, frame = self.cap.read()
            if not ret or frame is None:
                c = self.cfg.get()
                self._push_status(UiStatus(
                    error="Camera read failed",
                    engaged=self.engaged,
                    unlocked=self.unlocked,
                    pulse_active=self.pulse_active,
                    lock_on=self.lock_on,
                    angle_zero_latched=self.angle_zero_latched,
                    last_angle=self.last_sent_angle,
                    impact_flash=False,
                    fps=0.0,
                    rejected_n=0,
                    crash_radius_px=c["crash_radius_px"],
                    px_per_m=c["px_per_m"],
                    min_speed_px_s=c["min_speed_px_s"],
                    id_vote_window=c["id_vote_window"],
                    exposure=c["exposure"],
                    gain=c["gain"],
                    auto_exposure=c["auto_exposure"],
                ))
                time.sleep(0.05)
                continue

            now = time.perf_counter()
            now_s = time.time()

            # Read tunables once per frame
            c = self.cfg.get()
            crash_radius_px = c["crash_radius_px"]
            px_per_m = c["px_per_m"]
            min_speed_px_s = c["min_speed_px_s"]
            id_vote_window = c["id_vote_window"]
            angle_zero_thresh_rad = c["angle_zero_thresh_rad"]  # Added
            chaser_speed_px_s = SPHERE_SPEED_M_S * px_per_m

            # If UI changed vote window, resize vote deques without losing too much history
            if self.id_votes_target.maxlen != id_vote_window:
                old_t = list(self.id_votes_target)
                old_b = list(self.id_votes_ball)
                self.id_votes_target = deque(old_t[-id_vote_window:], maxlen=id_vote_window)
                self.id_votes_ball = deque(old_b[-id_vote_window:], maxlen=id_vote_window)

            out = frame.copy()

            if self.paused:
                draw_banner(out, "PAUSED", top_left=(20, 20), bg_color=(40, 40, 40))
                rgb = cv2.cvtColor(out, cv2.COLOR_BGR2RGB)
                fps = 1.0 / (time.perf_counter() - loop_start + 1e-9)
                self._push_frame(rgb)
                self._push_status(UiStatus(
                    error=None,
                    engaged=self.engaged,
                    unlocked=self.unlocked,
                    pulse_active=self.pulse_active,
                    lock_on=self.lock_on,
                    angle_zero_latched=self.angle_zero_latched,
                    last_angle=self.last_sent_angle,
                    impact_flash=(self.last_impact_event_t is not None) and ((time.time() - self.last_impact_event_t) <= CRASH_FLASH_S),
                    fps=float(fps),
                    rejected_n=0,
                    crash_radius_px=crash_radius_px,
                    px_per_m=px_per_m,
                    min_speed_px_s=min_speed_px_s,
                    id_vote_window=id_vote_window,
                    exposure=c["exposure"],
                    gain=c["gain"],
                    auto_exposure=c["auto_exposure"],
                ))
                continue

            gray = preprocess_gray(frame)
            corners, ids, rejected = aruco.detectMarkers(gray, ARUCO_DICT, parameters=ARUCO_PARAMS)

            ids_flat = None
            if ids is not None and len(ids) > 0:
                ids_flat = ids.flatten().astype(int)
                aruco.drawDetectedMarkers(out, corners, ids)

            # ---------- Engagement gate ----------
            if not self.engaged:
                draw_banner(out, "READY: Press ENGAGE", top_left=(20, 20), bg_color=(0, 70, 120))
                rgb = cv2.cvtColor(out, cv2.COLOR_BGR2RGB)
                fps = 1.0 / (time.perf_counter() - loop_start + 1e-9)
                self._push_frame(rgb)
                self._push_status(UiStatus(
                    error=None,
                    engaged=False,
                    unlocked=self.unlocked,
                    pulse_active=self.pulse_active,
                    lock_on=self.lock_on,
                    angle_zero_latched=self.angle_zero_latched,
                    last_angle=self.last_sent_angle,
                    impact_flash=False,
                    fps=float(fps),
                    rejected_n=0 if rejected is None else len(rejected),
                    crash_radius_px=crash_radius_px,
                    px_per_m=px_per_m,
                    min_speed_px_s=min_speed_px_s,
                    id_vote_window=id_vote_window,
                    exposure=c["exposure"],
                    gain=c["gain"],
                    auto_exposure=c["auto_exposure"],
                ))
                continue

            # ---------- Critical watch (Criti-Bot engage) ----------
            critical_seen = False
            if ids_flat is not None:
                critical_seen = (CRITIBOT_ID in ids_flat)

            if critical_seen:
                self.last_seen_critical_t = now
                if self.armed and not self.pulse_active:
                    self.pulse_active = True
                    self.pulse_start_time = now
                    self.last_critical_send_t = 0.0
                    self.armed = False
                    self.unlocked = True

            if self.pulse_active:
                if (now - self.pulse_start_time) <= PULSE_DURATION_S:
                    if (now - self.last_critical_send_t) >= self.critical_send_interval:
                        self.sock_critical.sendto(TRIGGER_BYTE, (UDP_IP, UDP_PORT_CRITICAL))
                        self.last_critical_send_t = now
                else:
                    self.pulse_active = False

            if (not critical_seen) and (not self.armed):
                if self.last_seen_critical_t is not None and (now - self.last_seen_critical_t) >= REARM_TIMEOUT_S:
                    self.armed = True

            if not self.unlocked:
                draw_banner(out, "WAITING FOR CRITI-BOT SIGNAL", top_left=(20, 20), bg_color=(120, 50, 0))
                rgb = cv2.cvtColor(out, cv2.COLOR_BGR2RGB)
                fps = 1.0 / (time.perf_counter() - loop_start + 1e-9)
                self._push_frame(rgb)
                self._push_status(UiStatus(
                    error=None,
                    engaged=True,
                    unlocked=False,
                    pulse_active=self.pulse_active,
                    lock_on=False,
                    angle_zero_latched=self.angle_zero_latched,
                    last_angle=self.last_sent_angle,
                    impact_flash=False,
                    fps=float(fps),
                    rejected_n=0 if rejected is None else len(rejected),
                    crash_radius_px=crash_radius_px,
                    px_per_m=px_per_m,
                    min_speed_px_s=min_speed_px_s,
                    id_vote_window=id_vote_window,
                    exposure=c["exposure"],
                    gain=c["gain"],
                    auto_exposure=c["auto_exposure"],
                ))
                continue

            # ---------- Unlocked: tracking ----------
            seen_target = False
            seen_ball = False
            p_target = None
            p_ball = None
            ball_corners = None

            detections = []
            if ids_flat is not None:
                for i, mid in enumerate(ids_flat):
                    c4 = corners[i][0]
                    pt = centroid_from_corners(c4)
                    detections.append((int(mid), pt, i))

                for mid, pt, i in detections:
                    if mid == TARGET_ID:
                        self.id_votes_target.append(mid)
                    if mid == ROBOBALL_ID:
                        self.id_votes_ball.append(mid)

                t_id, t_votes = majority_vote(self.id_votes_target)
                b_id, b_votes = majority_vote(self.id_votes_ball)

                t_allowed = (t_id == TARGET_ID and t_votes >= ID_MIN_VOTES)
                b_allowed = (b_id == ROBOBALL_ID and b_votes >= ID_MIN_VOTES)

                def pick(expected_id, last_pos, allowed):
                    if not detections:
                        return None
                    candidates = [(mid, pt, i) for (mid, pt, i) in detections if mid == expected_id]
                    if allowed and candidates:
                        if last_pos is None:
                            return candidates[0]
                        candidates.sort(key=lambda x: dist2(x[1], last_pos))
                        return candidates[0]

                    if last_pos is not None:
                        close = [(mid, pt, i) for (mid, pt, i) in detections
                                 if dist2(pt, last_pos) <= GATE_DIST_PX * GATE_DIST_PX]
                        if close:
                            close.sort(key=lambda x: dist2(x[1], last_pos))
                            return close[0]
                    return None

                pick_t = pick(TARGET_ID, getattr(self, "pos_target_filt", None), t_allowed)
                pick_b = pick(ROBOBALL_ID, getattr(self, "pos_ball_filt", None), b_allowed)

                if pick_t is not None:
                    _, pt, _ = pick_t
                    seen_target = True
                    self.last_seen_target_t = now
                    self.pos_target_filt = pt.copy() if self.pos_target_filt is None else (1.0 - ALPHA_POS) * self.pos_target_filt + ALPHA_POS * pt
                    p_target = self.pos_target_filt
                    self.hist_target.append((now, p_target.copy()))

                    p_int = (int(p_target[0]), int(p_target[1]))
                    if self.last_trail_pt is None:
                        self.trail_target.append(p_int)
                        self.last_trail_pt = p_int
                    else:
                        ddx = p_int[0] - self.last_trail_pt[0]
                        ddy = p_int[1] - self.last_trail_pt[1]
                        if ddx * ddx + ddy * ddy >= MIN_STEP_PX * MIN_STEP_PX:
                            self.trail_target.append(p_int)
                            self.last_trail_pt = p_int

                    cv2.circle(out, p_int, 6, (0, 255, 0), -1)

                if pick_b is not None:
                    _, pt, idx = pick_b
                    seen_ball = True
                    self.last_seen_ball_t = now
                    ball_corners = corners[idx][0]
                    self.pos_ball_filt = pt.copy() if self.pos_ball_filt is None else (1.0 - ALPHA_POS) * self.pos_ball_filt + ALPHA_POS * pt
                    p_ball = self.pos_ball_filt
                    self.hist_ball.append((now, p_ball.copy()))
                    cv2.circle(out, (int(p_ball[0]), int(p_ball[1])), 6, (255, 255, 0), -1)

            # Lost bridging
            if (not seen_target) and (self.last_seen_target_t is not None) and ((now - self.last_seen_target_t) <= LOST_TIMEOUT_S):
                p_target = self.pos_target_filt
                seen_target = p_target is not None
            if (not seen_ball) and (self.last_seen_ball_t is not None) and ((now - self.last_seen_ball_t) <= LOST_TIMEOUT_S):
                p_ball = self.pos_ball_filt
                seen_ball = p_ball is not None

            # Trail
            if len(self.trail_target) >= 2:
                pts = np.array(self.trail_target, dtype=np.int32).reshape((-1, 1, 2))
                cv2.polylines(out, [pts], False, (0, 255, 255), 2)

            # ---------- Impact detection (uses live crash_radius_px) ----------
            if (p_target is not None) and (p_ball is not None):
                dx = float(p_ball[0] - p_target[0])
                dy = float(p_ball[1] - p_target[1])
                d = math.hypot(dx, dy)

                cv2.circle(out, (int(p_target[0]), int(p_target[1])), int(crash_radius_px), (0, 200, 200), 2)

                if (not self.impact_latched) and (d <= crash_radius_px):
                    if (now_s - self.last_impact_pulse_t) >= MIN_PULSE_PERIOD_S:
                        self.send_impact_pulse(now_s)
                    self.impact_latched = True
                elif self.impact_latched and (d >= (crash_radius_px + HYST_PX)):
                    self.impact_latched = False

            impact_flash_active = (self.last_impact_event_t is not None) and ((now_s - self.last_impact_event_t) <= CRASH_FLASH_S)
            if impact_flash_active:
                phase = math.sin(2.0 * math.pi * CRASH_FLASH_HZ * (now_s - self.last_impact_event_t))
                if phase > 0.0:
                    overlay = out.copy()
                    cv2.rectangle(overlay, (0, 0), (FRAME_W, FRAME_H), (0, 0, 255), -1)
                    out = cv2.addWeighted(overlay, 0.35, out, 0.65, 0)
                    draw_banner(out, "IMPACT CONFIRMED", top_left=(20, 20), bg_color=(0, 0, 180), scale=1.0)

            # ---------- Intercept + angle stream (uses live min_speed_px_s + px_per_m) ----------
            if self.ip_last_seen_t is not None and (now - self.ip_last_seen_t) > IP_LOST_RESET_S:
                self.ip_stable_count = 0
                self.ip_last = None
                self.ip_last_seen_t = None
                self.lock_on = False
                self.angle_zero_count = 0
                self.angle_zero_latched = False

            v_target = estimate_velocity(self.hist_target)

            if seen_target and (p_target is not None) and (v_target is not None):
                speed = float(np.linalg.norm(v_target))
                if speed >= min_speed_px_s:
                    A = p_target.astype(np.float64)
                    u = (v_target / (speed + 1e-12)).astype(np.float64)
                    B = (A + u * float(PATH_LEN_PX)).astype(np.float64)
                    cv2.line(out, (int(A[0]), int(A[1])), (int(B[0]), int(B[1])), (255, 0, 255), 3, cv2.LINE_AA)

                    if seen_ball and (p_ball is not None):
                        P = p_ball.astype(np.float64)
                        IP, t_hit = compute_intercept_point(A, v_target, P, chaser_speed_px_s, t_max=MAX_INTERCEPT_T)
                        if IP is not None:
                            IP_int = (int(IP[0]), int(IP[1]))
                            cv2.line(out, (int(P[0]), int(P[1])), IP_int, (255, 0, 255), 2, cv2.LINE_AA)
                            draw_x(out, IP_int, size=14, color=(255, 0, 255), thickness=3)

                            self.ip_last_seen_t = now
                            if self.ip_last is None:
                                self.ip_last = IP.copy()
                                self.ip_stable_count = 0
                            else:
                                step = float(np.linalg.norm(IP - self.ip_last))
                                self.ip_stable_count = (self.ip_stable_count + 1) if (step <= IP_STABLE_PX) else 0
                                self.ip_last = IP.copy()

                            ip_stable = (self.ip_stable_count >= IP_STABLE_FRAMES)
                            if (not self.lock_on) and ip_stable:
                                self.lock_on = True

                            if self.lock_on and (ball_corners is not None):
                                can_send = True
                                if self.last_udp_sent_time is not None:
                                    can_send = (now - self.last_udp_sent_time) >= self.angle_send_min_dt

                                if can_send:
                                    c0 = ball_corners[0]
                                    c1 = ball_corners[1]
                                    hx = float(c1[0] - c0[0])
                                    hy = float(c1[1] - c0[1])

                                    heading = wrap_to_pi(angle_from_vec(hx, hy) + HEADING_OFFSET_RAD)

                                    ddx = float(IP[0] - P[0])
                                    ddy = float(IP[1] - P[1])
                                    desired = angle_from_vec(ddx, ddy)

                                    ang_err = wrap_to_pi(desired - heading)
                                    if FLIP_ANGLE_SIGN:
                                        ang_err = -ang_err

                                    if self.angle_zero_latched:
                                        ang_to_send = 0.0
                                    else:
                                        if abs(ang_err) <= angle_zero_thresh_rad:  # Changed from ANGLE_ZERO_THRESH_RAD
                                            self.angle_zero_count += 1
                                            if self.angle_zero_count >= ANGLE_ZERO_FRAMES:
                                                self.angle_zero_latched = True
                                            ang_to_send = 0.0
                                        else:
                                            self.angle_zero_count = 0
                                            ang_to_send = float(ang_err)

                                    self.sock_angle.sendto(struct.pack("<f", float(ang_to_send)), (UDP_IP, UDP_PORT_ANGLE))
                                    self.last_udp_sent_time = now
                                    self.last_sent_angle = float(ang_to_send)
                                    self.last_sent_time = now

            # Minimal on-frame overlay
            if self.pulse_active:
                draw_banner(out, "ENGAGE PULSE", top_left=(20, 20), bg_color=(0, 120, 0))
            elif self.unlocked:
                if impact_flash_active:
                    pass
                elif self.lock_on:
                    draw_banner(out, "LOCK-ON", top_left=(20, 20), bg_color=(90, 0, 120))
                else:
                    draw_banner(out, "TRACKING", top_left=(20, 20), bg_color=(30, 30, 30))

            fps = 1.0 / (time.perf_counter() - loop_start + 1e-9)
            rgb = cv2.cvtColor(out, cv2.COLOR_BGR2RGB)
            self._push_frame(rgb)

            self._push_status(UiStatus(
                error=None,
                engaged=self.engaged,
                unlocked=self.unlocked,
                pulse_active=self.pulse_active,
                lock_on=self.lock_on,
                angle_zero_latched=self.angle_zero_latched,
                last_angle=self.last_sent_angle,
                impact_flash=impact_flash_active,
                fps=float(fps),
                rejected_n=0 if rejected is None else len(rejected),
                crash_radius_px=crash_radius_px,
                px_per_m=px_per_m,
                min_speed_px_s=min_speed_px_s,
                id_vote_window=id_vote_window,
                exposure=c["exposure"],
                gain=c["gain"],
                auto_exposure=c["auto_exposure"],
            ))

        self.shutdown()


# ============================================================
# UI
# ============================================================

class App(ctk.CTk):
    def __init__(self):
        super().__init__()
        ctk.set_appearance_mode("dark")
        ctk.set_default_color_theme("dark-blue")

        self.title("Robo-Ball vs Criti-Bot — Attack Console")
        self.geometry("1500x900")
        self.minsize(1250, 780)
        self.protocol("WM_DELETE_WINDOW", self.on_quit)

        self.q = queue.Queue(maxsize=10)
        self.cfg = SharedConfig()

        self.runner = VisionRunner(self.q, self.cfg)
        self.worker = threading.Thread(target=self.runner.run, daemon=True)
        self.worker.start()

        # Layout
        self.grid_columnconfigure(0, weight=4)
        self.grid_columnconfigure(1, weight=2)
        self.grid_rowconfigure(0, weight=1)

        # --- Video area (left) ---
        self.video_frame = ctk.CTkFrame(self, corner_radius=14)
        self.video_frame.grid(row=0, column=0, padx=(12, 6), pady=12, sticky="nsew")
        self.video_frame.grid_rowconfigure(0, weight=1)
        self.video_frame.grid_columnconfigure(0, weight=1)

        self.video_label = ctk.CTkLabel(self.video_frame, text="")
        self.video_label.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")
        self.video_label.configure(width=1020, height=720)
        self.video_label.grid_propagate(False)

        self._ctk_img = None

        # --- Control area (right) ---
        self.panel = ctk.CTkScrollableFrame(self, corner_radius=14)
        self.panel.grid(row=0, column=1, padx=(6, 12), pady=12, sticky="nsew")
        self.panel.grid_columnconfigure(0, weight=1)

        self.state_badge = ctk.CTkLabel(self.panel, text="SAFE", font=ctk.CTkFont(size=28, weight="bold"))
        self.state_badge.grid(row=0, column=0, padx=14, pady=(14, 10), sticky="ew")

        # Primary controls
        self.btn_engage = ctk.CTkButton(self.panel, text="ENGAGE (Start)", height=44, command=self.on_engage)
        self.btn_engage.grid(row=1, column=0, padx=14, pady=(0, 10), sticky="ew")

        self.btn_pause = ctk.CTkButton(self.panel, text="PAUSE VISION", height=40, command=self.on_pause)
        self.btn_pause.grid(row=2, column=0, padx=14, pady=8, sticky="ew")

        self.btn_clear = ctk.CTkButton(self.panel, text="CLEAR TRACK", height=40, command=self.on_clear)
        self.btn_clear.grid(row=3, column=0, padx=14, pady=8, sticky="ew")

        self.btn_reset = ctk.CTkButton(self.panel, text="FULL RESET", height=40, command=self.on_reset)
        self.btn_reset.grid(row=4, column=0, padx=14, pady=8, sticky="ew")

        row2 = ctk.CTkFrame(self.panel, fg_color="transparent")
        row2.grid(row=5, column=0, padx=14, pady=(12, 8), sticky="ew")
        row2.grid_columnconfigure(0, weight=1)
        row2.grid_columnconfigure(1, weight=1)

        self.btn_snap = ctk.CTkButton(row2, text="SNAPSHOT", command=self.on_snapshot)
        self.btn_snap.grid(row=0, column=0, padx=(0, 6), sticky="ew")

        self.btn_quit = ctk.CTkButton(row2, text="QUIT", fg_color="#8b0000", command=self.on_quit)
        self.btn_quit.grid(row=0, column=1, padx=(6, 0), sticky="ew")

        # --- Live tuning section ---
        self._row = 6
        self._add_section_title("Tuning: Attack Behaviour")

        # Crash radius slider
        self.crash_var = ctk.IntVar(value=DEFAULT_CRASH_RADIUS_PX)
        self._add_slider_int(
            label="Impact Radius (px)",
            var=self.crash_var,
            from_=30, to=400,
            command=lambda v: self.cfg.set_crash_radius(int(float(v)))
        )

        # PX_PER_M slider
        self.pxpm_var = ctk.DoubleVar(value=DEFAULT_PX_PER_M)
        self._add_slider_float(
            label="Scale PX_PER_M (px per meter)",
            var=self.pxpm_var,
            from_=5.0, to=100.0,
            command=lambda v: self.cfg.set_px_per_m(float(v))
        )

        # Min speed slider
        self.minspeed_var = ctk.DoubleVar(value=DEFAULT_MIN_SPEED_PX_S)
        self._add_slider_float(
            label="Min Target Speed (px/s)",
            var=self.minspeed_var,
            from_=0.0, to=80.0,
            command=lambda v: self.cfg.set_min_speed(float(v))
        )

        # Vote window slider
        self.vote_var = ctk.IntVar(value=DEFAULT_ID_VOTE_WINDOW)
        self._add_slider_int(
            label="ID Vote Window (frames)",
            var=self.vote_var,
            from_=1, to=25,
            command=lambda v: self.cfg.set_id_vote_window(int(float(v)))
        )

        self.angthresh_var = ctk.DoubleVar(value=DEFAULT_ANGLE_ZERO_THRESH_RAD)  # Added
        self._add_slider_float(
            label="Angle Zero Threshold (rad)",
            var=self.angthresh_var,
            from_=0.00, to=1.50,
            command=lambda v: self.cfg.set_angle_thresh(float(v))
        )

        self._add_section_title("Camera Controls")

        # Auto exposure toggle
        self.autoexp_var = ctk.BooleanVar(value=DEFAULT_AUTO_EXPOSURE)
        auto_row = ctk.CTkFrame(self.panel, fg_color="transparent")
        auto_row.grid(row=self._row, column=0, padx=14, pady=(4, 2), sticky="ew")
        auto_row.grid_columnconfigure(0, weight=1)
        self._row += 1

        ctk.CTkLabel(auto_row, text="Auto Exposure").grid(row=0, column=0, sticky="w")
        self.autoexp_switch = ctk.CTkSwitch(
            auto_row, text="",
            variable=self.autoexp_var,
            command=self.on_camera_changed
        )
        self.autoexp_switch.grid(row=0, column=1, sticky="e")

        # Exposure slider
        self.exposure_var = ctk.DoubleVar(value=DEFAULT_EXPOSURE)
        self._add_slider_float(
            label="Exposure (driver units)",
            var=self.exposure_var,
            from_=-13.0, to=-1.0,
            command=lambda v: self.on_camera_changed()
        )

        # Gain slider
        self.gain_var = ctk.DoubleVar(value=DEFAULT_GAIN)
        self._add_slider_float(
            label="Gain",
            var=self.gain_var,
            from_=0.0, to=255.0,
            command=lambda v: self.on_camera_changed()
        )

        # Apply camera button
        self.btn_apply_cam = ctk.CTkButton(self.panel, text="APPLY CAMERA SETTINGS", command=self.on_apply_camera)
        self.btn_apply_cam.grid(row=self._row, column=0, padx=14, pady=(10, 10), sticky="ew")
        self._row += 1

        # Telemetry box
        self.telemetry = ctk.CTkTextbox(self.panel, height=240, wrap="word")
        self.telemetry.grid(row=self._row, column=0, padx=14, pady=(10, 14), sticky="ew")
        self.telemetry.configure(state="disabled")
        self._row += 1

        # Hotkeys
        self.bind("<Return>", lambda e: self.on_engage())
        self.bind("<space>", lambda e: self.on_pause())
        self.bind("<c>", lambda e: self.on_clear())
        self.bind("<r>", lambda e: self.on_reset())
        self.bind("<q>", lambda e: self.on_quit())
        self.bind("<s>", lambda e: self.on_snapshot())

        self.after(UI_POLL_MS, self.poll_queue)

    # --- helpers for UI layout ---
    def _add_section_title(self, title: str):
        lbl = ctk.CTkLabel(self.panel, text=title, font=ctk.CTkFont(size=18, weight="bold"))
        lbl.grid(row=self._row, column=0, padx=14, pady=(18, 8), sticky="w")
        self._row += 1

    def _add_slider_int(self, label: str, var: ctk.IntVar, from_: int, to: int, command):
        frame = ctk.CTkFrame(self.panel)
        frame.grid(row=self._row, column=0, padx=14, pady=6, sticky="ew")
        frame.grid_columnconfigure(0, weight=1)
        self._row += 1

        top = ctk.CTkFrame(frame, fg_color="transparent")
        top.grid(row=0, column=0, padx=10, pady=(8, 0), sticky="ew")
        top.grid_columnconfigure(0, weight=1)
        lbl = ctk.CTkLabel(top, text=label)
        lbl.grid(row=0, column=0, sticky="w")
        val = ctk.CTkLabel(top, text=str(var.get()))
        val.grid(row=0, column=1, sticky="e")

        def on_slide(v):
            iv = int(round(float(v)))
            var.set(iv)
            val.configure(text=str(iv))
            command(iv)

        slider = ctk.CTkSlider(frame, from_=from_, to=to, number_of_steps=(to - from_), command=on_slide)
        slider.set(var.get())
        slider.grid(row=1, column=0, padx=10, pady=(6, 10), sticky="ew")

    def _add_slider_float(self, label: str, var: ctk.DoubleVar, from_: float, to: float, command):
        frame = ctk.CTkFrame(self.panel)
        frame.grid(row=self._row, column=0, padx=14, pady=6, sticky="ew")
        frame.grid_columnconfigure(0, weight=1)
        self._row += 1

        top = ctk.CTkFrame(frame, fg_color="transparent")
        top.grid(row=0, column=0, padx=10, pady=(8, 0), sticky="ew")
        top.grid_columnconfigure(0, weight=1)
        lbl = ctk.CTkLabel(top, text=label)
        lbl.grid(row=0, column=0, sticky="w")
        val = ctk.CTkLabel(top, text=f"{var.get():.2f}")
        val.grid(row=0, column=1, sticky="e")

        def on_slide(v):
            fv = float(v)
            var.set(fv)
            val.configure(text=f"{fv:.2f}")
            command(fv)

        slider = ctk.CTkSlider(frame, from_=from_, to=to, command=on_slide)
        slider.set(var.get())
        slider.grid(row=1, column=0, padx=10, pady=(6, 10), sticky="ew")

    # --- UI actions ---
    def on_engage(self):
        self.runner.set_engaged(True)

    def on_pause(self):
        self.runner.toggle_pause()
        self.btn_pause.configure(text="RESUME VISION" if self.runner.paused else "PAUSE VISION")

    def on_clear(self):
        self.runner.clear_tracking_only()

    def on_reset(self):
        self.runner.full_reset()
        self.btn_pause.configure(text="PAUSE VISION")

    def on_snapshot(self):
        path = self.runner.snapshot()
        # This is just informational; we keep UI simple.
        if path:
            self._set_telemetry_prefix(f"Snapshot saved:\n{path}\n\n")
        else:
            self._set_telemetry_prefix("Snapshot failed: no frame yet.\n\n")

    def on_camera_changed(self):
        # Push values to shared config (doesn't force apply immediately unless requested)
        self.cfg.set_camera(
            auto_exposure=bool(self.autoexp_var.get()),
            exposure=float(self.exposure_var.get()),
            gain=float(self.gain_var.get())
        )
        # request apply so worker pushes to camera quickly
        self.cfg.request_apply_camera()

    def on_apply_camera(self):
        self.on_camera_changed()

    def on_quit(self):
        try:
            self.runner.request_stop()
        except Exception:
            pass
        self.after(120, self.destroy)

    # --- UI loop ---
    def poll_queue(self):
        latest_frame = None
        latest_status = None

        try:
            while True:
                kind, payload = self.q.get_nowait()
                if kind == "frame":
                    latest_frame = payload
                elif kind == "status":
                    latest_status = payload
        except queue.Empty:
            pass

        if latest_frame is not None:
            self._update_frame(latest_frame)

        if latest_status is not None:
            self._update_status(latest_status)

        self.after(UI_POLL_MS, self.poll_queue)

    def _update_frame(self, rgb_np: np.ndarray):
        h, w = rgb_np.shape[:2]
        target_w = 1020
        scale = target_w / float(w)
        target_h = int(h * scale)

        pil = Image.fromarray(rgb_np).resize((target_w, target_h))
        self._ctk_img = ctk.CTkImage(light_image=pil, dark_image=pil, size=(target_w, target_h))
        self.video_label.configure(image=self._ctk_img, text="")

    def _update_status(self, s: UiStatus):
        if s.error:
            badge = "ERROR"
        elif s.impact_flash:
            badge = "IMPACT"
        elif not s.engaged:
            badge = "SAFE"
        elif s.pulse_active:
            badge = "ENGAGING"
        elif s.unlocked and s.lock_on:
            badge = "LOCKED"
        elif s.unlocked:
            badge = "HUNTING"
        else:
            badge = "ARMED"

        self.state_badge.configure(text=badge)

        ang_txt = "—" if s.last_angle is None else f"{s.last_angle:+.3f} rad"

        text = (
            f"Mission: Robo-Ball attacks Criti-Bot\n\n"
            f"Engaged: {'Yes' if s.engaged else 'No'}\n"
            f"Unlocked (Criti-Bot seen): {'Yes' if s.unlocked else 'No'}\n"
            f"Lock-On Ready: {'Yes' if s.lock_on else 'No'}\n"
            f"Lock-On Complete (Angle=0 latch): {'Yes' if s.angle_zero_latched else 'No'}\n"
            f"Steering Angle Sent: {ang_txt}\n\n"
            f"FPS: {s.fps:.1f}\n"
            f"Rejected markers: {s.rejected_n}\n\n"
            f"--- Live Tunables ---\n"
            f"Impact radius: {s.crash_radius_px}px\n"
            f"PX_PER_M: {s.px_per_m:.2f}\n"
            f"Min speed: {s.min_speed_px_s:.2f}px/s\n"
            f"Vote window: {s.id_vote_window}\n"
            f"Auto exposure: {'On' if s.auto_exposure else 'Off'}\n"
            f"Exposure: {s.exposure:.2f}\n"
            f"Gain: {s.gain:.1f}\n"
        )
        if s.error:
            text = f"Error: {s.error}\n\n" + text

        self.telemetry.configure(state="normal")
        self.telemetry.delete("1.0", "end")
        self.telemetry.insert("end", text)
        self.telemetry.configure(state="disabled")

    def _set_telemetry_prefix(self, prefix: str):
        self.telemetry.configure(state="normal")
        current = self.telemetry.get("1.0", "end")
        self.telemetry.delete("1.0", "end")
        self.telemetry.insert("end", prefix + current)
        self.telemetry.configure(state="disabled")


if __name__ == "__main__":
    app = App()
    app.mainloop()
