import cv2
import cv2.aruco as aruco
import numpy as np
import time
from collections import deque

# ----------------------------
# CONFIG
# ----------------------------
ROBOT1_ID = 1                 # Target robot marker ID (ArUco)

MAX_HISTORY = 30              # points used for velocity estimation (R1)
ALPHA_POS = 0.35              # EMA smoothing for R1 position
MIN_STEP_PX = 2               # ignore jitter smaller than this (trail)

# Chaser capability (not used in perpendicular-foot method, but you can reuse later)
CHASER_SPEED_PX_S = 250.0

MAX_INTERCEPT_T = 3.0         # (not used in perpendicular-foot method)

PATH_LEN_PX = 800             # constant predicted path length on screen
MIN_SPEED_PX_S = 0.0          # below this, heading is unreliable

# ----------------------------
# SPHERE / CIRCLE TRACKING CONFIG
# ----------------------------
SPHERE_MIN_SPEED_PX_S = 10.0     # below this, velocity arrow is unreliable (optional use)
SPHERE_POS_EMA_ALPHA = 0.4
SPHERE_VEL_EMA_ALPHA = 0.35

# HoughCircles tuning (YOU MUST tune for your sphere + lighting)
DP = 1.2
MIN_DIST = 40
PARAM1 = 120
PARAM2 = 30
MIN_RADIUS = 30
MAX_RADIUS = 40

# ----------------------------
# ArUco setup
# ----------------------------
aruco_dict = aruco.getPredefinedDictionary(aruco.DICT_4X4_50)
parameters = aruco.DetectorParameters()

cap = cv2.VideoCapture(1)
cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1920)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 1080)

cv2.namedWindow("frame", cv2.WINDOW_AUTOSIZE)

# ----------------------------
# State buffers
# ----------------------------
# history entries for robot1: (t, np.array([x,y]))
hist1 = deque(maxlen=MAX_HISTORY)

trail1 = deque(maxlen=400)  # past trail for robot1
pos1_filt = None
last_trail1_pt = None

# Sphere state (replaces ArUco Robot2)
sphere_pos_f = None          # filtered position (float x,y)
sphere_vel_f = None          # filtered velocity (float vx,vy) in px/s
sphere_pos_prev = None
sphere_prev_t = None

# ----------------------------
# HELPERS
# ----------------------------
def ema(prev, new, alpha):
    if prev is None:
        return new
    return (1.0 - alpha) * prev + alpha * new

def centroid_from_corners(corners_4x2: np.ndarray) -> np.ndarray:
    return np.mean(corners_4x2, axis=0)

def maybe_append_trail(trail, pt_int):
    global last_trail1_pt
    last_pt = last_trail1_pt

    if last_pt is None:
        trail.append(pt_int)
        last_trail1_pt = pt_int
        return

    dx = pt_int[0] - last_pt[0]
    dy = pt_int[1] - last_pt[1]
    if dx*dx + dy*dy >= MIN_STEP_PX*MIN_STEP_PX:
        trail.append(pt_int)
        last_trail1_pt = pt_int

def estimate_velocity(history_deque):
    """
    Least-squares fit x(t), y(t) -> velocity (vx,vy) in px/s.
    """
    if len(history_deque) < 6:
        return None

    t = np.array([h[0] for h in history_deque], dtype=np.float64)
    p = np.array([h[1] for h in history_deque], dtype=np.float64)  # (N,2)

    t0 = t[0]
    tt = t - t0
    A = np.vstack([tt, np.ones_like(tt)]).T  # (N,2)

    vx, _bx = np.linalg.lstsq(A, p[:, 0], rcond=None)[0]
    vy, _by = np.linalg.lstsq(A, p[:, 1], rcond=None)[0]
    return np.array([float(vx), float(vy)], dtype=np.float64)

def draw_x(img, pt, size=12, color=(255, 0, 255), thickness=3):
    x, y = pt
    cv2.line(img, (x - size, y - size), (x + size, y + size), color, thickness, cv2.LINE_AA)
    cv2.line(img, (x - size, y + size), (x + size, y - size), color, thickness, cv2.LINE_AA)

def detect_and_update_sphere(frame_bgr, now_perf):
    """
    Runs HoughCircles on the current frame, updates sphere_pos_f/sphere_vel_f globals.
    Returns (seen_sphere: bool, sphere_pos_f (np.array shape(2)) or None).
    """
    global sphere_pos_f, sphere_vel_f, sphere_pos_prev, sphere_prev_t

    # Initialise timing for sphere velocity
    if sphere_prev_t is None:
        sphere_prev_t = now_perf

    gray = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2GRAY)
    gray = cv2.GaussianBlur(gray, (9, 9), 2)

    circles = cv2.HoughCircles(
        gray, cv2.HOUGH_GRADIENT,
        dp=DP,
        minDist=MIN_DIST,
        param1=PARAM1,
        param2=PARAM2,
        minRadius=MIN_RADIUS,
        maxRadius=MAX_RADIUS
    )

    if circles is None:
        # no detection this frame; keep timestamps updated to avoid dt explosions
        sphere_prev_t = now_perf
        return False, None, None  # (seen, pos, raw_circle)

    circles = np.squeeze(circles).astype(np.float32)
    if circles.ndim == 1:
        circles = circles[None, :]

    # pick best circle: largest radius (your previous heuristic)
    circles = sorted(circles, key=lambda c: c[2], reverse=True)
    x, y, r = circles[0]
    meas = np.array([float(x), float(y)], dtype=np.float64)

    # position EMA
    sphere_pos_f = ema(sphere_pos_f, meas, SPHERE_POS_EMA_ALPHA)

    # velocity from filtered position
    dt = max(1e-6, float(now_perf - sphere_prev_t))
    if sphere_pos_prev is None:
        sphere_pos_prev = sphere_pos_f.copy()

    v_meas = (sphere_pos_f - sphere_pos_prev) / dt
    sphere_vel_f = ema(sphere_vel_f, v_meas, SPHERE_VEL_EMA_ALPHA)

    sphere_pos_prev = sphere_pos_f.copy()
    sphere_prev_t = now_perf

    return True, sphere_pos_f, (x, y, r)

# ----------------------------
# MAIN LOOP
# ----------------------------
while True:
    loop_start = time.perf_counter()
    ret, frame = cap.read()
    if not ret or frame is None:
        print("Failed to grab frame.")
        break

    now = time.perf_counter()
    out = frame.copy()

    # ----------------------------
    # 1) Robot 1 (ArUco)
    # ----------------------------
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    corners, ids, rejected = aruco.detectMarkers(gray, aruco_dict, parameters=parameters)

    seen1 = False
    p1 = None

    if ids is not None and len(ids) > 0:
        ids_flat = ids.flatten()
        aruco.drawDetectedMarkers(out, corners, ids)

        for i, mid in enumerate(ids_flat):
            if int(mid) != ROBOT1_ID:
                continue

            c = corners[i][0]
            pt = centroid_from_corners(c)

            seen1 = True
            if pos1_filt is None:
                pos1_filt = pt.copy()
            else:
                pos1_filt = (1.0 - ALPHA_POS) * pos1_filt + ALPHA_POS * pt

            p1 = pos1_filt
            hist1.append((now, p1.copy()))

            p1_int = (int(p1[0]), int(p1[1]))
            maybe_append_trail(trail1, p1_int)
            cv2.circle(out, p1_int, 6, (0, 255, 0), -1)
            cv2.putText(out, f"R1 ID:{ROBOT1_ID}", (p1_int[0] + 10, p1_int[1] - 10),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2, cv2.LINE_AA)

    # Draw Robot 1 past trail
    if len(trail1) >= 2:
        pts = np.array(trail1, dtype=np.int32).reshape((-1, 1, 2))
        cv2.polylines(out, [pts], False, (0, 255, 255), 2)

    # ----------------------------
    # 2) Robot 2 replacement: Sphere tracking
    # ----------------------------
    seen2, p2, raw_circle = detect_and_update_sphere(frame, now)

    if seen2 and p2 is not None:
        p2_int = (int(p2[0]), int(p2[1]))
        cv2.circle(out, p2_int, 6, (255, 255, 0), -1)
        cv2.putText(out, "R2 (sphere)", (p2_int[0] + 10, p2_int[1] - 10),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 255, 0), 2, cv2.LINE_AA)

        # optional: draw detected raw circle outline for debugging
        if raw_circle is not None:
            x, y, r = raw_circle
            cv2.circle(out, (int(x), int(y)), int(r), (0, 255, 0), 2)

        # optional: draw sphere velocity arrow
        if sphere_vel_f is not None:
            speed2 = float(np.linalg.norm(sphere_vel_f))
            if speed2 >= SPHERE_MIN_SPEED_PX_S:
                u2 = sphere_vel_f / max(speed2, 1e-9)
                tip = (int(p2[0] + u2[0] * 80), int(p2[1] + u2[1] * 80))
                cv2.arrowedLine(out, p2_int, tip, (255, 0, 0), 3, tipLength=0.25)

    # ----------------------------
    # 3) Predicted path for R1 + perpendicular intercept from sphere
    # ----------------------------
    v1 = estimate_velocity(hist1)

    if seen1 and p1 is not None and v1 is not None:
        speed1 = float(np.linalg.norm(v1))
 
        if speed1 >= MIN_SPEED_PX_S:
            u = (v1 / max(speed1, 1e-9)).astype(np.float64)   # unit heading
            A = p1.astype(np.float64)
            B = (p1 + u * PATH_LEN_PX).astype(np.float64)

            A_int = (int(A[0]), int(A[1]))
            B_int = (int(B[0]), int(B[1]))

            cv2.line(out, A_int, B_int, (255, 0, 255), 3, cv2.LINE_AA)
            cv2.putText(out, f"R1 v(px/s)=({v1[0]:.1f},{v1[1]:.1f})",
                        (20, 80), cv2.FONT_HERSHEY_SIMPLEX, 0.9,
                        (255, 255, 255), 2, cv2.LINE_AA)

            # Perpendicular from sphere to R1 predicted path segment
            if seen2 and p2 is not None:
                P = p2.astype(np.float64)

                tproj = float(np.dot(P - A, u))
                t_clamped = float(np.clip(tproj, 0.0, float(PATH_LEN_PX)))
                F = A + u * t_clamped

                F_int = (int(F[0]), int(F[1]))
                P_int = (int(P[0]), int(P[1]))

                cv2.line(out, P_int, F_int, (255, 0, 255), 2, cv2.LINE_AA)
                draw_x(out, F_int, size=14, color=(255, 0, 255), thickness=3)
                cv2.putText(out, "IP", (F_int[0] + 10, F_int[1] - 10),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 0, 255), 2, cv2.LINE_AA)

        else:
            cv2.putText(out, "Predicted path: speed too low / heading unstable",
                        (20, 80), cv2.FONT_HERSHEY_SIMPLEX, 0.9,
                        (0, 0, 255), 2, cv2.LINE_AA)
    else:
        cv2.putText(out, "R1 prediction: waiting for enough samples",
                    (20, 80), cv2.FONT_HERSHEY_SIMPLEX, 0.9,
                    (255, 255, 255), 2, cv2.LINE_AA)

    # ----------------------------
    # HUD
    # ----------------------------
    loop_end = time.perf_counter()
    fps = 1.0 / (loop_end - loop_start + 1e-9)
    cv2.putText(out, f"FPS: {fps:.1f} | 'c' clear | 'q' quit",
                (20, 40), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (255, 255, 255), 2, cv2.LINE_AA)

    cv2.imshow("frame", out)

    key = cv2.waitKey(1) & 0xFF
    if key == ord('q'):
        break
    if key == ord('c'):
        hist1.clear()
        trail1.clear()
        pos1_filt = None
        last_trail1_pt = None

        sphere_pos_f = None
        sphere_vel_f = None
        sphere_pos_prev = None
        sphere_prev_t = None

cap.release()
cv2.destroyAllWindows()
exit(0)
